Index: src/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Imports\r\nimport faulthandler\r\nimport json\r\nimport logging\r\nimport sys\r\nimport traceback\r\nfrom dataclasses import dataclass\r\nfrom datetime import time\r\nfrom logging.handlers import RotatingFileHandler\r\nfrom typing import Optional\r\n\r\nfrom PyQt6.QtCore import (\r\n    Qt,\r\n)\r\nfrom PyQt6.QtGui import (\r\n    QPalette,\r\n    QBrush,\r\n    QPixmap,\r\n    QAction,\r\n)\r\nfrom PyQt6.QtWidgets import (\r\n    QApplication,\r\n    QMessageBox,\r\n    QMainWindow,\r\n)\r\n\r\nfrom config.config import Config\r\nfrom core.neo4jmodel import Neo4jModel\r\nfrom ui.controller import WorldBuildingController\r\nfrom ui.main_window import WorldBuildingUI\r\n\r\n# Configure logging\r\nlogging.basicConfig(\r\n    level=logging.DEBUG, format=\"%(asctime)s - %(levelname)s - %(message)s\"\r\n)\r\n\r\nfaulthandler.enable()\r\n\r\n\r\ndef exception_hook(exctype, value, tb):\r\n    logging.critical(\"Unhandled exception\", exc_info=(exctype, value, tb))\r\n    traceback.print_exception(exctype, value, tb)\r\n    sys.__excepthook__(exctype, value, tb)\r\n    QMessageBox.critical(\r\n        None, \"Unhandled Exception\", f\"An unhandled exception occurred:\\n{value}\"\r\n    )\r\n\r\nsys.excepthook = exception_hook\r\n\r\n@dataclass\r\nclass AppComponents:\r\n    \"\"\"Container for main application components\"\"\"\r\n\r\n    ui: \"WorldBuildingUI\"\r\n    model: \"Neo4jModel\"\r\n    controller: \"WorldBuildingController\"\r\n    config: \"Config\"\r\n\r\n\r\nclass WorldBuildingApp(QMainWindow):\r\n    \"\"\"Main application class with improved initialization and error handling\"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize the main application window.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.components: Optional[AppComponents] = None\r\n        self.setObjectName(\"WorldBuildingApp\")\r\n        self.initialize_application()\r\n\r\n    def initialize_application(self) -> None:\r\n        \"\"\"\r\n        Initialize all application components with comprehensive error handling.\r\n        \"\"\"\r\n        try:\r\n            # 1. Load Configuration\r\n            config = self._load_configuration()\r\n\r\n            # 2. Setup Logging\r\n            self._setup_logging(config)\r\n\r\n            # 3. Initialize Database Model\r\n            model = self._initialize_database(config)\r\n\r\n            # 4 Setup UI\r\n            ui = self._setup_ui(None)\r\n\r\n            # 5. Initialize Controller\r\n            controller = self._initialize_controller(ui, model, config)\r\n\r\n            ui.controller = controller\r\n\r\n            # Store components for access\r\n            self.components = AppComponents(\r\n                ui=ui, model=model, controller=controller, config=config\r\n            )\r\n\r\n            # 6. Configure Window\r\n            self._configure_main_window()\r\n\r\n            # 8. Set Background Image\r\n\r\n            self.set_background_image(\"src/background.png\")\r\n\r\n            # 7. Show Window\r\n            self.show()\r\n\r\n            logging.info(\"Application initialized successfully\")\r\n\r\n        except Exception as e:\r\n            self._handle_initialization_error(e)\r\n\r\n    def set_background_image(self, image_path: str) -> None:\r\n        \"\"\"\r\n        Set the background image for the main window.\r\n\r\n        Args:\r\n            image_path (str): The path to the background image file.\r\n        \"\"\"\r\n        try:\r\n            palette = QPalette()\r\n            pixmap = QPixmap(image_path)\r\n            palette.setBrush(QPalette.ColorRole.Window, QBrush(pixmap))\r\n            self.setPalette(palette)\r\n            logging.info(f\"Background image set from {image_path}\")\r\n        except Exception as e:\r\n            logging.error(f\"Failed to set background image: {e}\")\r\n\r\n    def _load_configuration(self) -> \"Config\":\r\n        \"\"\"\r\n        Load application configuration with error handling.\r\n\r\n        Returns:\r\n            config.config.Config: The loaded configuration.\r\n\r\n        Raises:\r\n            RuntimeError: If the configuration file is not found or invalid.\r\n        \"\"\"\r\n        try:\r\n            config = Config(\"src/config.json\")\r\n            logging.info(\"Configuration loaded successfully\")\r\n            return config\r\n        except FileNotFoundError:\r\n            raise RuntimeError(\"Configuration file 'config.json' not found\")\r\n        except json.JSONDecodeError:\r\n            raise RuntimeError(\"Invalid JSON in configuration file\")\r\n        except Exception as e:\r\n            raise RuntimeError(f\"Error loading configuration: {str(e)}\")\r\n\r\n    def _setup_logging(self, config: \"Config\") -> None:\r\n        \"\"\"\r\n        Configure logging with rotation and formatting.\r\n\r\n        Args:\r\n            config (Config): The configuration instance.\r\n\r\n        Raises:\r\n            RuntimeError: If logging setup fails.\r\n        \"\"\"\r\n        try:\r\n            log_file = config.LOGGING_FILE\r\n            log_level = getattr(logging, config.LOGGING_LEVEL.upper())\r\n\r\n            # Create a rotating file handler\r\n            rotating_handler = RotatingFileHandler(\r\n                log_file,\r\n                maxBytes=1024 * 1024,\r\n                backupCount=5,  # 1MB per file, keep 5 backups\r\n            )\r\n\r\n            # Set up logging configuration\r\n            logging.basicConfig(\r\n                level=log_level,\r\n                format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n                handlers=[\r\n                    rotating_handler,\r\n                    logging.StreamHandler(),\r\n                ],\r\n            )\r\n            logging.info(\"Logging system initialized\")\r\n        except Exception as e:\r\n            raise RuntimeError(f\"Failed to setup logging: {str(e)}\")\r\n\r\n    def _initialize_database(self, config: \"Config\") -> \"Neo4jModel\":\r\n        \"\"\"\r\n        Initialize database connection with retry logic.\r\n\r\n        Args:\r\n            config (Config): The configuration instance.\r\n\r\n        Returns:\r\n            Neo4jModel: The initialized Neo4j model.\r\n\r\n        Raises:\r\n            RuntimeError: If database connection fails after retries.\r\n        \"\"\"\r\n        max_retries = 3\r\n        retry_delay = 2  # seconds\r\n\r\n        for attempt in range(max_retries):\r\n            try:\r\n                model = Neo4jModel(\r\n                    config.NEO4J_URI, config.NEO4J_USERNAME, config.NEO4J_PASSWORD\r\n                )\r\n                logging.info(\"Database connection established\")\r\n                return model\r\n            except Exception as e:\r\n                if attempt >= max_retries - 1:\r\n                    raise RuntimeError(\r\n                        f\"Failed to connect to database after {max_retries} attempts: {str(e)}\"\r\n                    )\r\n                logging.warning(\r\n                    f\"Database connection attempt {attempt + 1} failed: {e}\"\r\n                )\r\n                time.sleep(retry_delay)\r\n\r\n    def _setup_ui(self, controller) -> \"WorldBuildingUI\":\r\n        \"\"\"\r\n        Initialize user interface with error handling.\r\n\r\n        Args:\r\n            controller: The controller instance.\r\n\r\n        Returns:\r\n            ui.main_window.WorldBuildingUI: The initialized UI instance.\r\n\r\n        Raises:\r\n            RuntimeError: If UI initialization fails.\r\n        \"\"\"\r\n        try:\r\n            ui = WorldBuildingUI(controller)\r\n            logging.info(\"UI initialized successfully\")\r\n            return ui\r\n        except Exception as e:\r\n            raise RuntimeError(f\"Failed to initialize UI: {str(e)}\")\r\n\r\n    def _initialize_controller(\r\n        self, ui: \"WorldBuildingUI\", model: \"Neo4jModel\", config: \"Config\"\r\n    ) -> \"WorldBuildingController\":\r\n        \"\"\"\r\n        Initialize application controller with error handling.\r\n\r\n        Args:\r\n            ui (WorldBuildingUI): The UI instance.\r\n            model (Neo4jModel): The Neo4j model instance.\r\n            config (Config): The configuration instance.\r\n\r\n        Returns:\r\n            WorldBuildingController: The initialized controller instance.\r\n\r\n        Raises:\r\n            RuntimeError: If controller initialization fails.\r\n        \"\"\"\r\n        try:\r\n            controller = WorldBuildingController(ui, model, config)\r\n            logging.info(\"Controller initialized successfully\")\r\n            return controller\r\n        except Exception as e:\r\n            raise RuntimeError(f\"Failed to initialize controller: {str(e)}\")\r\n\r\n    def _configure_main_window(self) -> None:\r\n        \"\"\"\r\n        Configure main window properties with error handling.\r\n\r\n        Raises:\r\n            RuntimeError: If main window configuration fails.\r\n        \"\"\"\r\n        try:\r\n            self.setObjectName(\"WorldBuildingApp\")\r\n            self.setCentralWidget(self.components.ui)\r\n\r\n            # Set window title with version\r\n            self.setWindowTitle(f\"NeoRealmBuilder {self.components.config.VERSION}\")\r\n\r\n            # Ensure transparency is properly set\r\n            self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)\r\n            self.components.ui.setAttribute(\r\n                Qt.WidgetAttribute.WA_TranslucentBackground, True\r\n            )\r\n\r\n            # Set window size\r\n            self.resize(\r\n                self.components.config.UI_WINDOW_WIDTH,\r\n                self.components.config.UI_WINDOW_HEIGHT,\r\n            )\r\n            self.setMinimumSize(\r\n                self.components.config.UI_WINDOW_WIDTH,\r\n                self.components.config.UI_WINDOW_HEIGHT,\r\n            )\r\n\r\n            # Add Export menu to the main menu bar\r\n            self._add_export_menu()\r\n\r\n            logging.info(\r\n                f\"Window configured with size \"\r\n                f\"{self.components.config.UI_WINDOW_WIDTH}x\"\r\n                f\"{self.components.config.UI_WINDOW_HEIGHT}\"\r\n            )\r\n        except Exception as e:\r\n            raise RuntimeError(f\"Failed to configure main window: {str(e)}\")\r\n\r\n    def _add_export_menu(self):\r\n        \"\"\"\r\n        Add Export menu to the main menu bar.\r\n        \"\"\"\r\n        menu_bar = self.menuBar()\r\n        menu_bar.setObjectName(\"menuBar\")\r\n\r\n        export_menu = menu_bar.addMenu(\"Export\")\r\n\r\n        export_json_action = QAction(\"Export as JSON\", self)\r\n        export_json_action.triggered.connect(self.components.controller.export_as_json)\r\n        export_menu.addAction(export_json_action)\r\n\r\n        export_txt_action = QAction(\"Export as TXT\", self)\r\n        export_txt_action.triggered.connect(self.components.controller.export_as_txt)\r\n        export_menu.addAction(export_txt_action)\r\n\r\n        export_csv_action = QAction(\"Export as CSV\", self)\r\n        export_csv_action.triggered.connect(self.components.controller.export_as_csv)\r\n        export_menu.addAction(export_csv_action)\r\n\r\n        export_pdf_action = QAction(\"Export as PDF\", self)\r\n        export_pdf_action.triggered.connect(self.components.controller.export_as_pdf)\r\n        export_menu.addAction(export_pdf_action)\r\n\r\n    def _handle_initialization_error(self, error: Exception) -> None:\r\n        \"\"\"\r\n        Handle initialization errors with cleanup.\r\n\r\n        Args:\r\n            error (Exception): The initialization error.\r\n        \"\"\"\r\n        error_message = f\"Failed to initialize the application:\\n{str(error)}\"\r\n        logging.critical(error_message, exc_info=True)\r\n\r\n        QMessageBox.critical(self, \"Initialization Error\", error_message)\r\n\r\n        # Cleanup any partially initialized resources\r\n        self._cleanup_resources()\r\n\r\n        sys.exit(1)\r\n\r\n    def _cleanup_resources(self) -> None:\r\n        \"\"\"\r\n        Clean up application resources.\r\n        \"\"\"\r\n        if self.components:\r\n            if self.components.controller:\r\n                try:\r\n                    self.components.controller.cleanup()\r\n                except Exception as e:\r\n                    logging.error(f\"Error during controller cleanup: {e}\")\r\n\r\n            if self.components.model:\r\n                try:\r\n                    self.components.model.close()\r\n                except Exception as e:\r\n                    logging.error(f\"Error during model cleanup: {e}\")\r\n\r\n    def closeEvent(self, event) -> None:\r\n        \"\"\"\r\n        Handle application shutdown with proper cleanup.\r\n\r\n        Args:\r\n            event: The close event.\r\n        \"\"\"\r\n        logging.info(\"Application shutdown initiated\")\r\n\r\n        try:\r\n            # Clean up controller resources\r\n            if self.components and self.components.controller:\r\n                self.components.controller.cleanup()\r\n                logging.info(\"Controller resources cleaned up\")\r\n\r\n            # Clean up model resources\r\n            if self.components and self.components.model:\r\n                self.components.model.close()\r\n                logging.info(\"Model resources cleaned up\")\r\n\r\n            event.accept()\r\n            logging.info(\"Application shutdown completed successfully\")\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error during application shutdown: {e}\")\r\n            event.accept()  # Still close the application\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    try:\r\n        app = QApplication(sys.argv)\r\n        ex = WorldBuildingApp()\r\n        sys.exit(app.exec())\r\n    except Exception as e:\r\n        logging.critical(\"Unhandled exception in main loop\", exc_info=True)\r\n        sys.exit(1)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main.py b/src/main.py
--- a/src/main.py	(revision e7d16f6f56e7750d5faef1a52db54b0031677460)
+++ b/src/main.py	(date 1731176267143)
@@ -45,8 +45,10 @@
         None, "Unhandled Exception", f"An unhandled exception occurred:\n{value}"
     )
 
+
 sys.excepthook = exception_hook
 
+
 @dataclass
 class AppComponents:
     """Container for main application components"""
Index: src/core/neo4jmodel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import datetime\r\nimport logging\r\nfrom typing import Dict, Any\r\n\r\nfrom PyQt6.QtWidgets import QMessageBox\r\nfrom neo4j import GraphDatabase\r\n\r\nfrom core.neo4jworkers import QueryWorker, WriteWorker, DeleteWorker, SuggestionWorker\r\nfrom utils.converters import NamingConventionConverter as ncc\r\n\r\n\r\nclass Neo4jModel:\r\n    \"\"\"Gateway to the Neo4j database\"\"\"\r\n\r\n    def __init__(self, uri, username, password):\r\n        \"\"\"\r\n        Initialize Neo4j connection parameters and establish connection.\r\n\r\n        Args:\r\n            uri (str): The URI of the Neo4j database.\r\n            username (str): The username for authentication.\r\n            password (str): The password for authentication.\r\n        \"\"\"\r\n        self._uri = uri\r\n        self._auth = (username, password)\r\n        self._driver = None\r\n        self.connect()\r\n        logging.info(\"Neo4jModel initialized and connected to the database.\")\r\n\r\n    def connect(self):\r\n\r\n        if not self._driver:\r\n            self._driver = GraphDatabase.driver(self._uri, auth=self._auth)\r\n\r\n    def ensure_connection(self):\r\n\r\n        try:\r\n            if self._driver:\r\n                self._driver.verify_connectivity()\r\n            else:\r\n                self.connect()\r\n        except Exception as e:\r\n            logging.warning(f\"Connection verification failed: {e}\")\r\n            self.connect()\r\n\r\n    def get_session(self):\r\n        \"\"\"\r\n        Get a database session, ensuring connection is valid.\r\n\r\n        Returns:\r\n            The database session.\r\n        \"\"\"\r\n        self.ensure_connection()\r\n        return self._driver.session()\r\n\r\n    def close(self):\r\n        \"\"\"\r\n        Safely close the driver.\r\n        \"\"\"\r\n        if self._driver:\r\n            try:\r\n                self._driver.close()\r\n            finally:\r\n                self._driver = None\r\n        logging.info(\"Neo4jModel connection closed.\")\r\n\r\n    #############################################\r\n    # 2. Node CRUD Operations\r\n    #############################################\r\n\r\n    def validate_node_data(self, node_data):\r\n        \"\"\"\r\n        Validate node data before performing any operations.\r\n\r\n        Args:\r\n            node_data (dict): Node data including properties and relationships.\r\n\r\n        Raises:\r\n            ValueError: If validation fails.\r\n        \"\"\"\r\n        # Check for required fields\r\n        if \"name\" not in node_data or not node_data[\"name\"].strip():\r\n            raise ValueError(\"Node must have a non-empty name.\")\r\n\r\n        if \"labels\" not in node_data or not node_data[\"labels\"]:\r\n            raise ValueError(\"Node must have at least one label.\")\r\n\r\n        # Check for proper labels\r\n        for label in node_data[\"labels\"]:\r\n            if not label.strip():\r\n                raise ValueError(\"Node labels must be non-empty.\")\r\n\r\n        return True\r\n\r\n    def load_node(self, name, callback):\r\n        \"\"\"\r\n        Load a node and its relationships by name using a worker.\r\n\r\n        Args:\r\n            name (str): Name of the node to load.\r\n            callback (function): Function to call with the result.\r\n\r\n        Returns:\r\n            QueryWorker: A worker that will execute the query.\r\n        \"\"\"\r\n        query = \"\"\"\r\n            MATCH (n {name: $name})\r\n            WITH n, labels(n) AS labels,\r\n                 [(n)-[r]->(m) | {end: m.name, type: type(r), dir: '>', props: properties(r)}] AS out_rels,\r\n                 [(n)<-[r2]-(o) | {end: o.name, type: type(r2), dir: '<', props: properties(r2)}] AS in_rels,\r\n                 properties(n) AS all_props\r\n            RETURN n,\r\n                   out_rels + in_rels AS relationships,\r\n                   labels,\r\n                   all_props\r\n            LIMIT 1\r\n        \"\"\"\r\n        params = {\"name\": name}\r\n        worker = QueryWorker(self._uri, self._auth, query, params)\r\n        worker.query_finished.connect(callback)\r\n        return worker\r\n\r\n    def save_node(self, node_data, callback):\r\n        \"\"\"\r\n        Save or update a node and its relationships using a worker.\r\n\r\n        Args:\r\n            node_data (dict): Node data including properties and relationships.\r\n            callback (function): Function to call when done.\r\n\r\n        Returns:\r\n            WriteWorker: A worker that will execute the write operation.\r\n        \"\"\"\r\n        self.validate_node_data(node_data)\r\n        worker = WriteWorker(\r\n            self._uri, self._auth, self._save_node_transaction, node_data\r\n        )\r\n        worker.write_finished.connect(callback)\r\n        return worker\r\n\r\n    @staticmethod\r\n    def _save_node_transaction(tx, node_data):\r\n        \"\"\"\r\n        Private transaction handler for save_node.\r\n        Preserves and updates system properties (_created, _modified, _author) while replacing all others.\r\n        \"\"\"\r\n        logging.debug(\"+++++++++++++++++ Starting Save Node Transaction +++++++++++++++++++++++\")\r\n\r\n        # Enforce naming style conventions\r\n\r\n        logging.debug(f\"Node data to save: {node_data}\")\r\n        logging.debug(f\"Node data is of type: {type(node_data)}\")\r\n        original_node_data=node_data\r\n        node_data=ncc.convert_node_data(node_data)\r\n\r\n        # Compare the original and converted data and give feedback on automatic conversion\r\n        # Feedback is in form of an info message popup\r\n\r\n        if original_node_data != node_data:\r\n            logging.info(\"Node data was automatically converted to adhere to naming conventions.\")\r\n            logging.info(f\"Original data: {original_node_data}\")\r\n            logging.info(f\"Converted data: {node_data}\")\r\n            QMessageBox.information(None, \"Naming Convention Conversion\",\r\n                                    \"Node data was automatically converted to adhere to naming conventions.\\n\"\r\n                                    f\"Original data: {original_node_data}\\n\"\r\n                                    f\"Converted data: {node_data}\")\r\n\r\n        # Extract data from node_data\r\n        name = node_data[\"name\"]\r\n        description = node_data[\"description\"]\r\n        tags = node_data[\"tags\"]\r\n        additional_properties = node_data[\"additional_properties\"]\r\n        relationships = node_data[\"relationships\"]\r\n        labels = node_data[\"labels\"]\r\n\r\n        # 1. Get existing system properties\r\n        # Updated to specifically check for _created timestamp\r\n        query_get_system = \"\"\"\r\n        MATCH (n {name: $name})\r\n        RETURN n._created as created\r\n        \"\"\"\r\n        result = tx.run(query_get_system, name=name)\r\n        record = result.single()\r\n\r\n        # 2. Prepare system properties\r\n        system_props = {\r\n            \"_author\": \"System\",  # Always set author\r\n            \"_modified\": datetime.now().isoformat(),  # Always update modified time\r\n        }\r\n\r\n        # Only set _created if it doesn't exist\r\n        if not record or record[\"created\"] is None:\r\n            system_props[\"_created\"] = datetime.now().isoformat()\r\n        else:\r\n            system_props[\"_created\"] = record[\r\n                \"created\"\r\n            ]  # Preserve existing creation time\r\n\r\n        # Create a new node if it doesn't exist\r\n        if not record:\r\n            query_create = \"\"\"\r\n            CREATE (n {name: $name, description: $description, tags: $tags})\r\n            \"\"\"\r\n            tx.run(query_create, name=name, description=description, tags=tags)\r\n\r\n        # 3. Reset node with core properties and system properties\r\n        base_props = {\r\n            \"name\": name,\r\n            \"description\": description,\r\n            \"tags\": tags,\r\n            **system_props,  # Include system properties in base set\r\n        }\r\n\r\n        query_reset = \"\"\"\r\n        MATCH (n {name: $name})\r\n        SET n = $base_props\r\n        \"\"\"\r\n        tx.run(query_reset, name=name, base_props=base_props)\r\n\r\n        # 4. Handle labels\r\n        result = tx.run(\"MATCH (n {name: $name}) RETURN labels(n) AS labels\", name=name)\r\n        record = result.single()\r\n        existing_labels = record[\"labels\"] if record else []\r\n        existing_labels = [label for label in existing_labels if label != \"Node\"]\r\n\r\n        # Determine labels to add and remove\r\n        input_labels_set = set(labels) - {\"Node\"}\r\n        existing_labels_set = set(existing_labels)\r\n        labels_to_add = input_labels_set - existing_labels_set\r\n        labels_to_remove = existing_labels_set - input_labels_set\r\n\r\n        # Add new labels\r\n        if labels_to_add:\r\n            labels_str = \":\".join([f\"`{label}`\" for label in labels_to_add])\r\n            query_add = f\"MATCH (n {{name: $name}}) SET n:{labels_str}\"\r\n            tx.run(query_add, name=name)\r\n\r\n        # Remove old labels\r\n        if labels_to_remove:\r\n            labels_str = \", \".join([f\"n:`{label}`\" for label in labels_to_remove])\r\n            query_remove = f\"MATCH (n {{name: $name}}) REMOVE {labels_str}\"\r\n            tx.run(query_remove, name=name)\r\n\r\n        # 5. Add non-system additional properties (if any)\r\n        filtered_additional_props = {\r\n            k: v for k, v in additional_properties.items() if not k.startswith(\"_\")\r\n        }\r\n        if filtered_additional_props:\r\n            query_props = \"MATCH (n {name: $name}) SET n += $additional_properties\"\r\n            tx.run(\r\n                query_props, name=name, additional_properties=filtered_additional_props\r\n            )\r\n\r\n        # 6. Handle relationships\r\n        # Remove existing relationships\r\n        query_remove_rels = \"MATCH (n {name: $name})-[r]-() DELETE r\"\r\n        tx.run(query_remove_rels, name=name)\r\n\r\n        # Create/update relationships\r\n        for rel in relationships:\r\n            rel_type, rel_name, direction, properties = rel\r\n            if direction == \">\":\r\n                query_rel = (\r\n                    f\"MATCH (n {{name: $name}}), (m {{name: $rel_name}}) \"\r\n                    f\"MERGE (n)-[r:`{rel_type}`]->(m) \"\r\n                    \"SET r = $properties\"\r\n                )\r\n            else:\r\n                query_rel = (\r\n                    f\"MATCH (n {{name: $name}}), (m {{name: $rel_name}}) \"\r\n                    f\"MERGE (n)<-[r:`{rel_type}`]-(m) \"\r\n                    \"SET r = $properties\"\r\n                )\r\n            tx.run(query_rel, name=name, rel_name=rel_name, properties=properties)\r\n\r\n        logging.debug(\"+++++++++++++++++ Finished Save Node Transaction +++++++++++++++++++++++\")\r\n\r\n    def delete_node(self, name, callback):\r\n        \"\"\"\r\n        Delete a node and all its relationships using a worker.\r\n\r\n        Args:\r\n            name (str): Name of the node to delete.\r\n            callback (function): Function to call when done.\r\n\r\n        Returns:\r\n            DeleteWorker: A worker that will execute the delete operation.\r\n        \"\"\"\r\n        worker = DeleteWorker(\r\n            self._uri, self._auth, self._delete_node_transaction, name\r\n        )\r\n        worker.delete_finished.connect(callback)\r\n        return worker\r\n\r\n    @staticmethod\r\n    def _delete_node_transaction(tx, name):\r\n        \"\"\"\r\n        Private transaction handler for delete_node.\r\n\r\n        Args:\r\n            tx: The transaction object.\r\n            name (str): Name of the node to delete.\r\n        \"\"\"\r\n        query = \"MATCH (n {name: $name}) DETACH DELETE n\"\r\n        tx.run(query, name=name)\r\n\r\n    #############################################\r\n    # 3. Node Query Operations\r\n    #############################################\r\n\r\n    def get_node_relationships(self, node_name: str, depth: int, callback: callable):\r\n        \"\"\"\r\n        Get the relationships of a node by name up to a specified depth using a worker.\r\n\r\n        Args:\r\n            node_name (str): Name of the node.\r\n            depth (int): The depth of relationships to retrieve.\r\n            callback (function): Function to call with the result.\r\n\r\n        Returns:\r\n            QueryWorker: A worker that will execute the query.\r\n        \"\"\"\r\n        depth += 1  # Adjust depth for query\r\n        query = f\"\"\"\r\n            MATCH path = (n {{name: $name}})-[*1..{depth}]-()\r\n            WHERE ALL(r IN relationships(path) WHERE startNode(r) IS NOT NULL AND endNode(r) IS NOT NULL)\r\n              AND ALL(node IN nodes(path) WHERE node IS NOT NULL)\r\n            WITH path, length(path) AS path_length\r\n            UNWIND range(1, path_length - 1) AS idx\r\n            WITH\r\n                nodes(path)[idx] AS current_node,\r\n                relationships(path)[idx - 1] AS current_rel,\r\n                nodes(path)[idx - 1] AS parent_node,\r\n                idx AS depth\r\n            RETURN DISTINCT\r\n                current_node.name AS node_name,\r\n                labels(current_node) AS labels,\r\n                parent_node.name AS parent_name,\r\n                type(current_rel) AS rel_type,\r\n                CASE\r\n                    WHEN startNode(current_rel) = parent_node THEN '>' ELSE '<' END AS direction,\r\n                depth\r\n            ORDER BY depth ASC\r\n        \"\"\"\r\n        params = {\"name\": node_name}\r\n        worker = QueryWorker(self._uri, self._auth, query, params)\r\n        worker.query_finished.connect(callback)\r\n        return worker\r\n\r\n    def get_node_hierarchy(self):\r\n        \"\"\"\r\n        Get the hierarchy of nodes grouped by their primary label.\r\n\r\n        Returns:\r\n            dict: Category to node names mapping.\r\n        \"\"\"\r\n        with self.get_session() as session:\r\n            result = session.run(\r\n                \"\"\"\r\n                MATCH (n:Node)\r\n                WITH n, labels(n) AS labels\r\n                WHERE size(labels) > 1\r\n                RETURN DISTINCT head(labels) as category, \r\n                       collect(n.name) as nodes\r\n                ORDER BY category\r\n            \"\"\"\r\n            )\r\n            return {record[\"category\"]: record[\"nodes\"] for record in result}\r\n\r\n    def fetch_matching_node_names(self, prefix, limit, callback):\r\n        \"\"\"\r\n        Search for nodes whose names match a given prefix using a worker.\r\n\r\n        Args:\r\n            prefix (str): The search prefix.\r\n            limit (int): Maximum number of results to return.\r\n            callback (function): Function to call with the result.\r\n\r\n        Returns:\r\n            QueryWorker: A worker that will execute the query.\r\n        \"\"\"\r\n        query = (\r\n            \"MATCH (n) WHERE toLower(n.name) CONTAINS toLower($prefix) \"\r\n            \"RETURN n.name AS name LIMIT $limit\"\r\n        )\r\n        params = {\"prefix\": prefix, \"limit\": limit}\r\n        worker = QueryWorker(self._uri, self._auth, query, params)\r\n        worker.query_finished.connect(callback)\r\n        return worker\r\n\r\n    def generate_suggestions(\r\n            self, node_data: Dict[str, Any], suggestions_callback: callable,\r\n            error_callback: callable\r\n    ):\r\n        \"\"\"\r\n        Generate suggestions for a given node using SuggestionWorker.\r\n\r\n        Args:\r\n            node_data (Dict[str, Any]): The data of the node for which to generate suggestions.\r\n            suggestions_callback (callable): The function to call with the suggestions when ready.\r\n            error_callback (callable): The function to call in case of errors.\r\n        \"\"\"\r\n        worker = SuggestionWorker(self._uri, self._auth, node_data)\r\n        worker.suggestions_ready.connect(suggestions_callback)\r\n        worker.error_occurred.connect(error_callback)\r\n\r\n        # Ensure the worker is removed from active_workers when finished\r\n        worker.finished.connect(lambda: self.active_workers.discard(worker))\r\n\r\n        # Add the worker to the active_workers set to keep a reference\r\n        self.active_workers.add(worker)\r\n\r\n        # Start the worker thread\r\n        worker.start()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/core/neo4jmodel.py b/src/core/neo4jmodel.py
--- a/src/core/neo4jmodel.py	(revision e7d16f6f56e7750d5faef1a52db54b0031677460)
+++ b/src/core/neo4jmodel.py	(date 1731176267164)
@@ -144,26 +144,33 @@
         Private transaction handler for save_node.
         Preserves and updates system properties (_created, _modified, _author) while replacing all others.
         """
-        logging.debug("+++++++++++++++++ Starting Save Node Transaction +++++++++++++++++++++++")
+        logging.debug(
+            "+++++++++++++++++ Starting Save Node Transaction +++++++++++++++++++++++"
+        )
 
         # Enforce naming style conventions
 
         logging.debug(f"Node data to save: {node_data}")
         logging.debug(f"Node data is of type: {type(node_data)}")
-        original_node_data=node_data
-        node_data=ncc.convert_node_data(node_data)
+        original_node_data = node_data
+        node_data = ncc.convert_node_data(node_data)
 
         # Compare the original and converted data and give feedback on automatic conversion
         # Feedback is in form of an info message popup
 
         if original_node_data != node_data:
-            logging.info("Node data was automatically converted to adhere to naming conventions.")
+            logging.info(
+                "Node data was automatically converted to adhere to naming conventions."
+            )
             logging.info(f"Original data: {original_node_data}")
             logging.info(f"Converted data: {node_data}")
-            QMessageBox.information(None, "Naming Convention Conversion",
-                                    "Node data was automatically converted to adhere to naming conventions.\n"
-                                    f"Original data: {original_node_data}\n"
-                                    f"Converted data: {node_data}")
+            QMessageBox.information(
+                None,
+                "Naming Convention Conversion",
+                "Node data was automatically converted to adhere to naming conventions.\n"
+                f"Original data: {original_node_data}\n"
+                f"Converted data: {node_data}",
+            )
 
         # Extract data from node_data
         name = node_data["name"]
@@ -273,7 +280,9 @@
                 )
             tx.run(query_rel, name=name, rel_name=rel_name, properties=properties)
 
-        logging.debug("+++++++++++++++++ Finished Save Node Transaction +++++++++++++++++++++++")
+        logging.debug(
+            "+++++++++++++++++ Finished Save Node Transaction +++++++++++++++++++++++"
+        )
 
     def delete_node(self, name, callback):
         """
@@ -389,8 +398,10 @@
         return worker
 
     def generate_suggestions(
-            self, node_data: Dict[str, Any], suggestions_callback: callable,
-            error_callback: callable
+        self,
+        node_data: Dict[str, Any],
+        suggestions_callback: callable,
+        error_callback: callable,
     ):
         """
         Generate suggestions for a given node using SuggestionWorker.
@@ -411,4 +422,4 @@
         self.active_workers.add(worker)
 
         # Start the worker thread
-        worker.start()
\ No newline at end of file
+        worker.start()
Index: src/ui/controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport logging\r\nfrom typing import Optional, Dict, Any, List\r\n\r\nfrom PyQt6.QtCore import QObject, QStringListModel, Qt, pyqtSlot, QTimer\r\nfrom PyQt6.QtGui import QStandardItemModel, QStandardItem, QIcon\r\nfrom PyQt6.QtWidgets import QAbstractItemView, QCompleter, QLineEdit, QMessageBox, QTableWidgetItem, \\\r\n    QFileDialog\r\n\r\nfrom core.neo4jworkers import SuggestionWorker\r\nfrom ui.dialogs import SuggestionDialog\r\n\r\n\r\nclass WorldBuildingController(QObject):\r\n    \"\"\"\r\n    Controller class managing interaction between UI and Neo4j model using QThread workers\r\n    \"\"\"\r\n\r\n    NODE_RELATIONSHIPS_HEADER = \"Node Relationships\"\r\n\r\n    def __init__(self, ui: \"WorldBuildingUI\", model: \"Neo4jModel\", config: \"Config\"):\r\n        \"\"\"\r\n        Initialize the controller with UI, model, and configuration.\r\n\r\n        Args:\r\n            ui (ui.main_window.WorldBuildingUI): The UI instance.\r\n            model (Neo4jModel): The Neo4j model instance.\r\n            config (config.config.Config): The configuration instance.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.ui = ui\r\n        self.model = model\r\n        self.config = config\r\n        self.current_image_path: Optional[str] = None\r\n        self.original_node_data: Optional[Dict[str, Any]] = None\r\n        self.ui.controller = self\r\n\r\n        # Initialize UI state\r\n        self._initialize_tree_view()\r\n        self._initialize_completer()\r\n        self._initialize_target_completer()\r\n        self._setup_debounce_timer()\r\n        self._connect_signals()\r\n        self._load_default_state()\r\n\r\n        # Initialize worker manager\r\n        self.current_load_worker = None\r\n        self.current_save_worker = None\r\n        self.current_relationship_worker = None\r\n        self.current_search_worker = None\r\n        self.current_delete_worker = None\r\n        self.current_suggestion_worker = None\r\n\r\n    #############################################\r\n    # 1. Initialization Methods\r\n    #############################################\r\n\r\n    def _initialize_tree_view(self):\r\n        \"\"\"\r\n        Initialize the tree view model.\r\n        \"\"\"\r\n        self.tree_model = QStandardItemModel()\r\n        self.tree_model.setHorizontalHeaderLabels([self.NODE_RELATIONSHIPS_HEADER])\r\n        self.ui.tree_view.setModel(self.tree_model)\r\n\r\n        self.ui.tree_view.setSelectionMode(\r\n            QAbstractItemView.SelectionMode.ExtendedSelection\r\n        )\r\n        self.ui.tree_view.setSelectionBehavior(\r\n            QAbstractItemView.SelectionBehavior.SelectItems\r\n        )\r\n\r\n        # connect selction signals\r\n        self.ui.tree_view.selectionModel().selectionChanged.connect(\r\n            self.on_tree_selection_changed\r\n        )\r\n\r\n        self.ui.tree_view.setUniformRowHeights(True)\r\n        self.ui.tree_view.setItemsExpandable(True)\r\n        self.ui.tree_view.setAllColumnsShowFocus(True)\r\n        self.ui.tree_view.setHeaderHidden(False)\r\n\r\n    def _initialize_completer(self):\r\n        \"\"\"\r\n        Initialize name auto-completion.\r\n        \"\"\"\r\n        self.node_name_model = QStringListModel()\r\n        self.completer = QCompleter(self.node_name_model)\r\n        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)\r\n        self.completer.setFilterMode(Qt.MatchFlag.MatchContains)\r\n        self.ui.name_input.setCompleter(self.completer)\r\n        self.completer.activated.connect(self.on_completer_activated)\r\n\r\n    def _initialize_target_completer(self):\r\n        \"\"\"\r\n        Initialize target auto-completion for relationship table.\r\n        \"\"\"\r\n        self.target_name_model = QStringListModel()\r\n        self.target_completer = QCompleter(self.target_name_model)\r\n        self.target_completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)\r\n        self.target_completer.setFilterMode(Qt.MatchFlag.MatchContains)\r\n        self.target_completer.activated.connect(self.on_target_completer_activated)\r\n\r\n    def _add_target_completer_to_row(self, row):\r\n        \"\"\"\r\n        Add target completer to the target input field in the relationship table.\r\n\r\n        Args:\r\n            row (int): The row number where the completer will be added.\r\n        \"\"\"\r\n        target_item = self.ui.relationships_table.item(row, 1)\r\n        if target_item:\r\n            target_text = target_item.text()\r\n            line_edit = QLineEdit(target_text)\r\n            line_edit.setCompleter(self.target_completer)\r\n            line_edit.textChanged.connect(\r\n                lambda text: self._fetch_matching_target_nodes(text)\r\n            )\r\n            self.ui.relationships_table.setCellWidget(row, 1, line_edit)\r\n\r\n    def on_target_completer_activated(self, text: str):\r\n        \"\"\"\r\n        Handle target completer selection.\r\n\r\n        Args:\r\n            text (str): The selected text from the completer.\r\n        \"\"\"\r\n        current_row = self.ui.relationships_table.currentRow()\r\n        if current_row >= 0:\r\n            self.ui.relationships_table.item(current_row, 1).setText(text)\r\n\r\n    def _fetch_matching_target_nodes(self, text: str):\r\n        \"\"\"\r\n        Fetch matching target nodes for auto-completion.\r\n\r\n        Args:\r\n            text (str): The text to match against node names.\r\n        \"\"\"\r\n        if not text:\r\n            return\r\n\r\n        # Cancel any existing search worker\r\n        if self.current_search_worker:\r\n            self.current_search_worker.cancel()\r\n            self.current_search_worker.wait()\r\n\r\n        self.current_search_worker = self.model.fetch_matching_node_names(\r\n            text,\r\n            self.config.NEO4J_MATCH_NODE_LIMIT,\r\n            self._handle_target_autocomplete_results,\r\n        )\r\n        self.current_search_worker.error_occurred.connect(self.handle_error)\r\n        self.current_search_worker.start()\r\n\r\n    @pyqtSlot(list)\r\n    def _handle_target_autocomplete_results(self, records: List[Any]):\r\n        \"\"\"\r\n        Handle target autocomplete results.\r\n\r\n        Args:\r\n            records (List[Any]): The list of matching records.\r\n        \"\"\"\r\n        try:\r\n            names = [record[\"name\"] for record in records]\r\n            self.target_name_model.setStringList(names)\r\n        except Exception as e:\r\n            self.handle_error(f\"Error processing target autocomplete results: {str(e)}\")\r\n\r\n    def _setup_debounce_timer(self):\r\n        \"\"\"\r\n        Setup debounce timer for search.\r\n        \"\"\"\r\n        self.name_input_timer = QTimer()\r\n        self.name_input_timer.setSingleShot(True)\r\n        self.name_input_timer.timeout.connect(self._fetch_matching_nodes)\r\n        self.name_input_timer.setInterval(\r\n            self.config.TIMING_NAME_INPUT_DEBOUNCE_TIME_MS\r\n        )\r\n\r\n    def _connect_signals(self):\r\n        \"\"\"\r\n        Connect all UI signals to handlers.\r\n        \"\"\"\r\n        # Main buttons\r\n        self.ui.save_button.clicked.connect(self.save_node)\r\n        self.ui.delete_button.clicked.connect(self.delete_node)\r\n\r\n        # Image handling\r\n        self.ui.change_image_button.clicked.connect(self.change_image)\r\n        self.ui.delete_image_button.clicked.connect(self.delete_image)\r\n\r\n        # Name input and autocomplete\r\n        self.ui.name_input.textChanged.connect(self.debounce_name_input)\r\n        self.ui.name_input.editingFinished.connect(self.load_node_data)\r\n\r\n        # Table buttons\r\n        self.ui.add_rel_button.clicked.connect(self.ui.add_relationship_row)\r\n\r\n        #connect the suggest button\r\n        self.ui.suggest_button.clicked.connect(self.show_suggestions_modal)\r\n\r\n        # Check for unsaved changes\r\n        self.ui.name_input.textChanged.connect(self.update_unsaved_changes_indicator)\r\n        self.ui.description_input.textChanged.connect(\r\n            self.update_unsaved_changes_indicator\r\n        )\r\n        self.ui.labels_input.textChanged.connect(self.update_unsaved_changes_indicator)\r\n        self.ui.tags_input.textChanged.connect(self.update_unsaved_changes_indicator)\r\n        self.ui.properties_table.itemChanged.connect(\r\n            self.update_unsaved_changes_indicator\r\n        )\r\n        self.ui.relationships_table.itemChanged.connect(\r\n            self.update_unsaved_changes_indicator\r\n        )\r\n\r\n\r\n\r\n        # Depth spinbox change\r\n        self.ui.depth_spinbox.valueChanged.connect(self.on_depth_changed)\r\n\r\n    def _load_default_state(self):\r\n        \"\"\"\r\n        Initialize default UI state.\r\n        \"\"\"\r\n        self.ui.name_input.clear()\r\n        self.ui.description_input.clear()\r\n        self.ui.labels_input.clear()\r\n        self.ui.tags_input.clear()\r\n        self.ui.properties_table.setRowCount(0)\r\n        self.ui.relationships_table.setRowCount(0)\r\n        self.refresh_tree_view()\r\n\r\n    #############################################\r\n    # 2. Node Operations\r\n    #############################################\r\n\r\n    def load_node_data(self):\r\n        \"\"\"\r\n        Load node data using worker thread.\r\n        \"\"\"\r\n        name = self.ui.name_input.text().strip()\r\n        if not name:\r\n            return\r\n\r\n        # Clear all fields to populate them again\r\n        self.ui.clear_all_fields()\r\n\r\n        # Cancel any existing load operation\r\n        if self.current_load_worker:\r\n            self.current_load_worker.cancel()\r\n            self.current_load_worker.wait()\r\n\r\n        # Start new load operation\r\n        self.current_load_worker = self.model.load_node(name, self._handle_node_data)\r\n        self.current_load_worker.error_occurred.connect(self.handle_error)\r\n        self.current_load_worker.start()\r\n\r\n        # Update relationship tree\r\n        self.update_relationship_tree(name)\r\n\r\n    def save_node(self):\r\n        \"\"\"\r\n        Save node data using worker thread.\r\n        \"\"\"\r\n        name = self.ui.name_input.text().strip()\r\n        if not self.validate_node_name(name):\r\n            return\r\n\r\n        node_data = self._collect_node_data()\r\n        if not node_data:\r\n            return\r\n\r\n        # Cancel any existing save operation\r\n        if hasattr(self, \"current_save_worker\") and self.current_save_worker:\r\n            self.current_save_worker.cancel()\r\n\r\n        # Start new save operation\r\n        self.current_save_worker = self.model.save_node(node_data, self.on_save_success)\r\n        self.current_save_worker.error_occurred.connect(self.handle_error)\r\n        self.current_save_worker.start()\r\n\r\n    def delete_node(self):\r\n        \"\"\"\r\n        Delete node using worker thread.\r\n        \"\"\"\r\n        name = self.ui.name_input.text().strip()\r\n        if not name:\r\n            return\r\n\r\n        reply = QMessageBox.question(\r\n            self.ui,\r\n            \"Confirm Deletion\",\r\n            f'Are you sure you want to delete node \"{name}\"?',\r\n            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,\r\n            QMessageBox.StandardButton.No,\r\n        )\r\n\r\n        if reply == QMessageBox.StandardButton.Yes:\r\n            # Cancel any existing delete operation\r\n            if self.current_delete_worker:\r\n                self.current_delete_worker.cancel()\r\n                self.current_delete_worker.wait()\r\n\r\n            # Start new delete operation\r\n            self.current_delete_worker = self.model.delete_node(\r\n                name, self._handle_delete_success\r\n            )\r\n            self.current_delete_worker.error_occurred.connect(self.handle_error)\r\n            self.current_delete_worker.start()\r\n\r\n    #############################################\r\n    # 3. Tree and Relationship Management\r\n    #############################################\r\n\r\n    def on_depth_changed(self, value: int):\r\n        \"\"\"\r\n        Handle changes in relationship depth.\r\n\r\n        Args:\r\n            value (int): The new depth value.\r\n        \"\"\"\r\n        node_name = self.ui.name_input.text().strip()\r\n        if node_name:\r\n            self.update_relationship_tree(node_name)\r\n\r\n    def update_relationship_tree(self, node_name: str):\r\n        \"\"\"\r\n        Update tree view with node relationships.\r\n\r\n        Args:\r\n            node_name (str): The name of the node.\r\n        \"\"\"\r\n        if not node_name:\r\n            self.tree_model.clear()\r\n            self.tree_model.setHorizontalHeaderLabels([self.NODE_RELATIONSHIPS_HEADER])\r\n            return\r\n\r\n        depth = self.ui.depth_spinbox.value()  # Get depth from UI\r\n\r\n        # Cancel any existing relationship worker\r\n        if self.current_relationship_worker:\r\n            self.current_relationship_worker.cancel()\r\n            self.current_relationship_worker.wait()\r\n\r\n        self.current_relationship_worker = self.model.get_node_relationships(\r\n            node_name, depth, self._populate_relationship_tree\r\n        )\r\n        self.current_relationship_worker.error_occurred.connect(self.handle_error)\r\n        self.current_relationship_worker.start()\r\n\r\n    def refresh_tree_view(self):\r\n        \"\"\"\r\n        Refresh the entire tree view.\r\n        \"\"\"\r\n        name = self.ui.name_input.text().strip()\r\n        if name:\r\n            self.update_relationship_tree(name)\r\n\r\n    def on_tree_selection_changed(self, selected, deselected):\r\n        \"\"\"\r\n        Handle tree view selection changes.\r\n\r\n        Args:\r\n            selected: The selected indexes.\r\n            deselected: The deselected indexes.\r\n        \"\"\"\r\n        indexes = selected.indexes()\r\n        if indexes:\r\n            selected_item = self.tree_model.itemFromIndex(indexes[0])\r\n            if selected_item:\r\n                node_name = selected_item.data(Qt.ItemDataRole.UserRole)\r\n                if node_name and node_name != self.ui.name_input.text():\r\n                    self.ui.name_input.setText(node_name)\r\n                    self.load_node_data()\r\n\r\n    #############################################\r\n    # 4. Auto-completion and Search\r\n    #############################################\r\n\r\n    def show_suggestions_modal(self):\r\n        node_data = self._collect_node_data()\r\n        if not node_data:\r\n            return\r\n\r\n        # Show loading indicator\r\n        self.ui.show_loading(True)\r\n\r\n        # Cancel any existing SuggestionWorker\r\n        if self.current_suggestion_worker:\r\n            self.current_suggestion_worker.cancel()\r\n            self.current_suggestion_worker.wait()\r\n            self.current_suggestion_worker = None\r\n            logging.debug(\"Existing SuggestionWorker canceled and cleaned up.\")\r\n\r\n        # Create and start the SuggestionWorker\r\n        self.current_suggestion_worker = SuggestionWorker(self.model._uri, self.model._auth,\r\n                                                          node_data)\r\n        self.current_suggestion_worker.suggestions_ready.connect(self.handle_suggestions)\r\n        self.current_suggestion_worker.error_occurred.connect(self.handle_error)\r\n        self.current_suggestion_worker.finished.connect(self.on_suggestion_worker_finished)\r\n        self.current_suggestion_worker.start()\r\n\r\n        logging.debug(\"SuggestionWorker started successfully.\")\r\n\r\n    def on_suggestion_worker_finished(self):\r\n        \"\"\"\r\n        Cleanup after SuggestionWorker has finished.\r\n        \"\"\"\r\n        self.current_suggestion_worker = None\r\n        self.ui.show_loading(False)\r\n        logging.debug(\"SuggestionWorker has finished and cleaned up.\")\r\n\r\n    def handle_suggestions(self, suggestions):\r\n        \"\"\"\r\n        Handle the suggestions received from the SuggestionWorker.\r\n\r\n        Args:\r\n            suggestions (dict): The suggestions dictionary containing tags, properties, and relationships.\r\n        \"\"\"\r\n        logging.debug(f\"handle_suggestions called with suggestions: {suggestions}\")\r\n        # Hide loading indicator\r\n        self.ui.show_loading(False)\r\n        logging.debug(\"Loading indicator hidden.\")\r\n\r\n        if not suggestions or all(not suggestions[key] for key in suggestions):\r\n            logging.debug(\"No suggestions found.\")\r\n            QMessageBox.information(self.ui, \"No Suggestions\",\r\n                                    \"No suggestions were found for this node.\")\r\n            return\r\n\r\n        dialog = SuggestionDialog(suggestions, self.ui)\r\n        if dialog.exec():\r\n            selected = dialog.selected_suggestions\r\n            logging.debug(f\"User selected suggestions: {selected}\")\r\n\r\n            # Update tags\r\n            existing_tags = self._parse_comma_separated(self.ui.tags_input.text())\r\n            new_tags = list(set(existing_tags + selected['tags']))\r\n            self.ui.tags_input.setText(', '.join(new_tags))\r\n            logging.debug(f\"Updated tags: {new_tags}\")\r\n\r\n            # Update properties\r\n            for key, value in selected['properties'].items():\r\n                self.add_or_update_property(key, value)\r\n                logging.debug(f\"Updated property - Key: {key}, Value: {value}\")\r\n\r\n            # Update relationships\r\n            for rel in selected['relationships']:\r\n                rel_type, target, direction, props = rel\r\n                self.ui.add_relationship_row(rel_type, target, direction, json.dumps(props))\r\n                logging.debug(\r\n                    f\"Added relationship - Type: {rel_type}, Target: {target}, Direction: {direction}, Properties: {props}\")\r\n\r\n            QMessageBox.information(self.ui, \"Suggestions Applied\",\r\n                                    \"Selected suggestions have been applied to the node.\")\r\n        else:\r\n            logging.debug(\"Suggestion dialog was canceled by the user.\")\r\n\r\n    def add_or_update_property(self, key, value):\r\n        found = False\r\n        for row in range(self.ui.properties_table.rowCount()):\r\n            item_key = self.ui.properties_table.item(row, 0)\r\n            if item_key and item_key.text() == key:\r\n                self.ui.properties_table.item(row, 1).setText(str(value))\r\n                found = True\r\n                break\r\n        if not found:\r\n            row = self.ui.properties_table.rowCount()\r\n            self.ui.properties_table.insertRow(row)\r\n            self.ui.properties_table.setItem(row, 0, QTableWidgetItem(key))\r\n            self.ui.properties_table.setItem(row, 1, QTableWidgetItem(str(value)))\r\n            delete_button = self.ui.create_delete_button(self.ui.properties_table, row)\r\n            self.ui.properties_table.setCellWidget(row, 2, delete_button)\r\n\r\n    def debounce_name_input(self, text: str):\r\n        \"\"\"\r\n        Debounce name input for search.\r\n\r\n        Args:\r\n            text (str): The input text.\r\n        \"\"\"\r\n        self.name_input_timer.stop()\r\n        if text.strip():\r\n            self.name_input_timer.start()\r\n\r\n    def _fetch_matching_nodes(self):\r\n        \"\"\"\r\n        Fetch matching nodes for auto-completion.\r\n        \"\"\"\r\n        text = self.ui.name_input.text().strip()\r\n        if not text:\r\n            return\r\n\r\n        # Cancel any existing search worker\r\n        if self.current_search_worker:\r\n            self.current_search_worker.cancel()\r\n            self.current_search_worker.wait()\r\n\r\n        self.current_search_worker = self.model.fetch_matching_node_names(\r\n            text, self.config.NEO4J_MATCH_NODE_LIMIT, self._handle_autocomplete_results\r\n        )\r\n        self.current_search_worker.error_occurred.connect(self.handle_error)\r\n        self.current_search_worker.start()\r\n\r\n    def on_completer_activated(self, text: str):\r\n        \"\"\"\r\n        Handle completer selection.\r\n\r\n        Args:\r\n            text (str): The selected text from the completer.\r\n        \"\"\"\r\n        if text:\r\n            self.ui.name_input.setText(text)\r\n            self.load_node_data()\r\n\r\n    #############################################\r\n    # 5. Data Collection and Validation\r\n    #############################################\r\n\r\n    def _collect_node_data(self) -> Optional[Dict[str, Any]]:\r\n        \"\"\"\r\n        Collect all node data from UI.\r\n\r\n        Returns:\r\n            Optional[Dict[str, Any]]: The collected node data.\r\n        \"\"\"\r\n        try:\r\n            node_data = {\r\n                \"name\": self.ui.name_input.text().strip(),\r\n                \"description\": self.ui.description_input.toPlainText().strip(),\r\n                \"tags\": self._parse_comma_separated(self.ui.tags_input.text()),\r\n                \"labels\": [\r\n                    label.strip().upper().replace(\" \", \"_\")\r\n                    for label in self._parse_comma_separated(\r\n                        self.ui.labels_input.text()\r\n                    )\r\n                ],\r\n                \"relationships\": self._collect_relationships(),\r\n                \"additional_properties\": self._collect_properties(),\r\n            }\r\n\r\n            if self.current_image_path:\r\n                node_data[\"additional_properties\"][\r\n                    \"image_path\"\r\n                ] = self.current_image_path\r\n            else:\r\n                node_data[\"additional_properties\"][\"image_path\"] = None\r\n\r\n            logging.debug(f\"Collected Node Data: {node_data}\")\r\n\r\n            return node_data\r\n        except ValueError as e:\r\n            self.handle_error(str(e))\r\n            return None\r\n\r\n    def _collect_properties(self) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Collect properties from table.\r\n\r\n        Returns:\r\n            Dict[str, Any]: The collected properties.\r\n        \"\"\"\r\n        properties = {}\r\n        for row in range(self.ui.properties_table.rowCount()):\r\n            key = self.ui.properties_table.item(row, 0)\r\n            value = self.ui.properties_table.item(row, 1)\r\n\r\n            if not key or not key.text().strip():\r\n                continue\r\n\r\n            key_text = key.text().strip()\r\n\r\n            if key_text.lower() in self.config.RESERVED_PROPERTY_KEYS:\r\n                raise ValueError(f\"Property key '{key_text}' is reserved\")\r\n\r\n            if key_text.startswith(\"_\"):\r\n                raise ValueError(\r\n                    f\"Property key '{key_text}' cannot start with an underscore\"\r\n                )\r\n\r\n            try:\r\n                value_text = value.text().strip() if value else \"\"\r\n                properties[key_text] = (\r\n                    json.loads(value_text) if value_text else value_text\r\n                )\r\n            except json.JSONDecodeError:\r\n                properties[key_text] = value_text\r\n\r\n        return properties\r\n\r\n    def _collect_relationships(self) -> List[tuple]:\r\n        \"\"\"\r\n        Collect relationships from table.\r\n\r\n        Returns:\r\n            List[tuple]: The collected relationships.\r\n        \"\"\"\r\n        relationships = []\r\n        for row in range(self.ui.relationships_table.rowCount()):\r\n            rel_type = self.ui.relationships_table.item(row, 0)\r\n            target = self.ui.relationships_table.cellWidget(row, 1)\r\n            direction = self.ui.relationships_table.cellWidget(row, 2)\r\n            props = self.ui.relationships_table.item(row, 3)\r\n\r\n            if not all([rel_type, target, direction]):\r\n                continue\r\n\r\n            try:\r\n                properties = (\r\n                    json.loads(props.text()) if props and props.text().strip() else {}\r\n                )\r\n\r\n                # Enforce uppercase and replace spaces with underscores\r\n                formatted_rel_type = rel_type.text().strip().upper().replace(\" \", \"_\")\r\n\r\n                relationships.append(\r\n                    (\r\n                        formatted_rel_type,\r\n                        target.text().strip(),\r\n                        direction.currentText(),\r\n                        properties,\r\n                    )\r\n                )\r\n            except json.JSONDecodeError as e:\r\n                raise ValueError(f\"Invalid JSON in relationship properties: {e}\")\r\n\r\n        logging.debug(f\"Collected the following Relationships: {relationships}\")\r\n        return relationships\r\n\r\n    #############################################\r\n    # 6. Event Handlers\r\n    #############################################\r\n\r\n    @pyqtSlot(list)\r\n    def _handle_node_data(self, data: List[Any]):\r\n        \"\"\"\r\n        Handle node data fetched by the worker.\r\n\r\n        Args:\r\n            data (List[Any]): The fetched node data.\r\n        \"\"\"\r\n        logging.debug(f\"Handling node data: {data}\")\r\n        if not data:\r\n            return  # No need to notify the user\r\n\r\n        try:\r\n            record = data[0]  # Extract the first record\r\n            self._populate_node_fields(record)\r\n            self.original_node_data = self._collect_node_data()\r\n        except Exception as e:\r\n            self.handle_error(f\"Error populating node fields: {str(e)}\")\r\n\r\n    def is_node_changed(self) -> bool:\r\n        \"\"\"\r\n        Check if the node data has changed.\r\n\r\n        Returns:\r\n            bool: Whether the node data has changed.\r\n        \"\"\"\r\n        current_data = self._collect_node_data()\r\n        return current_data != self.original_node_data\r\n\r\n    def update_unsaved_changes_indicator(self):\r\n        if self.is_node_changed():\r\n            self.ui.save_button.setStyleSheet(\"background-color: #83A00E;\")\r\n        else:\r\n            self.ui.save_button.setStyleSheet(\"background-color: #d3d3d3;\")\r\n\r\n    def _handle_delete_success(self, _):\r\n        \"\"\"\r\n        Handle successful node deletion.\r\n\r\n        Args:\r\n            _: The result of the delete operation.\r\n        \"\"\"\r\n        QMessageBox.information(self.ui, \"Success\", \"Node deleted successfully\")\r\n        self._load_default_state()\r\n\r\n    def on_save_success(self, _):\r\n        \"\"\"\r\n        Handle successful node save.\r\n\r\n        Args:\r\n            _: The result of the save operation.\r\n        \"\"\"\r\n        QMessageBox.information(self.ui, \"Success\", \"Node saved successfully\")\r\n        self.refresh_tree_view()\r\n        self.load_node_data()\r\n\r\n    @pyqtSlot(list)\r\n    def _handle_autocomplete_results(self, records: List[Any]):\r\n        \"\"\"\r\n        Handle autocomplete results.\r\n\r\n        Args:\r\n            records (List[Any]): The list of matching records.\r\n        \"\"\"\r\n        try:\r\n            names = [record[\"name\"] for record in records]\r\n            self.node_name_model.setStringList(names)\r\n        except Exception as e:\r\n            self.handle_error(f\"Error processing autocomplete results: {str(e)}\")\r\n\r\n    def _update_save_progress(self, current: int, total: int):\r\n        \"\"\"\r\n        Update progress during save operation.\r\n\r\n        Args:\r\n            current (int): The current progress value.\r\n            total (int): The total progress value.\r\n        \"\"\"\r\n        # Could be connected to a progress bar in the UI\r\n        logging.info(f\"Save progress: {current}/{total}\")\r\n\r\n    @pyqtSlot(object)\r\n    def _populate_node_fields(self, record):\r\n        \"\"\"\r\n        Populate UI fields with node data.\r\n\r\n        Args:\r\n            record: The record containing node data.\r\n        \"\"\"\r\n        logging.debug(f\"Populating node fields with record: {record}\")\r\n        try:\r\n            # Extract data from the record\r\n            node = record[\"n\"]\r\n            labels = record[\"labels\"]\r\n            relationships = record[\"relationships\"]\r\n            properties = record[\"all_props\"]\r\n\r\n            # Ensure node properties are accessed correctly\r\n            node_properties = dict(node)\r\n            node_name = node_properties.get(\"name\", \"\")\r\n            node_description = node_properties.get(\"description\", \"\")\r\n            node_tags = node_properties.get(\"tags\", [])\r\n            image_path = node_properties.get(\"image_path\")\r\n\r\n            # Update UI elements in the main thread\r\n            self.ui.name_input.setText(node_name)\r\n            self.ui.description_input.setPlainText(node_description)\r\n            self.ui.labels_input.setText(\", \".join(labels))\r\n            self.ui.tags_input.setText(\", \".join(node_tags))\r\n\r\n            # Update properties table\r\n            self.ui.properties_table.setRowCount(0)\r\n            for key, value in properties.items():\r\n\r\n                if key.startswith(\"_\"):\r\n                    continue\r\n\r\n                if key not in [\"name\", \"description\", \"tags\", \"image_path\"]:\r\n\r\n                    row = self.ui.properties_table.rowCount()\r\n                    self.ui.properties_table.insertRow(row)\r\n                    self.ui.properties_table.setItem(row, 0, QTableWidgetItem(key))\r\n                    self.ui.properties_table.setItem(\r\n                        row, 1, QTableWidgetItem(str(value))\r\n                    )\r\n                    delete_button = self.ui.create_delete_button(\r\n                        self.ui.properties_table, row\r\n                    )\r\n                    self.ui.properties_table.setCellWidget(row, 2, delete_button)\r\n\r\n            # Update relationships table\r\n            self.ui.relationships_table.setRowCount(0)\r\n            for rel in relationships:\r\n                rel_type = rel.get(\"type\", \"\")\r\n                target = rel.get(\"end\", \"\")\r\n                direction = rel.get(\"dir\", \">\")\r\n                props = json.dumps(rel.get(\"props\", {}))\r\n\r\n                self.ui.add_relationship_row(rel_type, target, direction, props)\r\n\r\n            # Update image if available\r\n            self.current_image_path = image_path\r\n            self.ui.set_image(image_path)\r\n\r\n            logging.info(\"Node data populated successfully.\")\r\n\r\n        except Exception as e:\r\n            self.handle_error(f\"Error populating node fields: {str(e)}\")\r\n\r\n    def process_relationship_records(self, records):\r\n        \"\"\"\r\n        Process relationship records and build parent-child map.\r\n\r\n        Args:\r\n            records (List[Any]): The list of relationship records.\r\n\r\n        Returns:\r\n            dict: A dictionary mapping parent names to their child nodes with relationship details.\r\n        \"\"\"\r\n        parent_child_map = {}\r\n        skipped_records = 0\r\n\r\n        for record in records:\r\n            node_name = record.get(\"node_name\")\r\n            labels = record.get(\"labels\", [])\r\n            parent_name = record.get(\"parent_name\")\r\n            rel_type = record.get(\"rel_type\")\r\n            direction = record.get(\"direction\")\r\n\r\n            if not node_name or not parent_name or not rel_type or not direction:\r\n                logging.warning(f\"Incomplete record encountered and skipped: {record}\")\r\n                skipped_records += 1\r\n                continue\r\n\r\n            key = (parent_name, rel_type, direction)\r\n            if key not in parent_child_map:\r\n                parent_child_map[key] = []\r\n            parent_child_map[key].append((node_name, labels))\r\n\r\n        return parent_child_map, skipped_records\r\n\r\n    def add_children(self, parent_name, parent_item, path, parent_child_map):\r\n        \"\"\"\r\n        Add child nodes to the relationship tree with checkboxes.\r\n        \"\"\"\r\n        for (p_name, rel_type, direction), children in parent_child_map.items():\r\n            if p_name != parent_name:\r\n                continue\r\n\r\n            for child_name, child_labels in children:\r\n                if child_name in path:\r\n                    self.handle_cycles(parent_item, rel_type, direction, child_name)\r\n                    continue\r\n\r\n                arrow = \"➡\uFE0F\" if direction == \">\" else \"⬅\uFE0F\"\r\n\r\n                # Create relationship item (non-checkable separator)\r\n                rel_item = QStandardItem(f\"{arrow} [{rel_type}]\")\r\n                rel_item.setFlags(\r\n                    Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable\r\n                )\r\n\r\n                # Create node item (checkable)\r\n                child_item = QStandardItem(\r\n                    f\"\uD83D\uDD39 {child_name} [{', '.join(child_labels)}]\"\r\n                )\r\n                child_item.setData(child_name, Qt.ItemDataRole.UserRole)\r\n                child_item.setFlags(\r\n                    Qt.ItemFlag.ItemIsEnabled\r\n                    | Qt.ItemFlag.ItemIsSelectable\r\n                    | Qt.ItemFlag.ItemIsUserCheckable\r\n                )\r\n                child_item.setCheckState(Qt.CheckState.Unchecked)\r\n\r\n                rel_item.appendRow(child_item)\r\n                parent_item.appendRow(rel_item)\r\n\r\n                self.add_children(\r\n                    child_name, child_item, path + [child_name], parent_child_map\r\n                )\r\n\r\n    def handle_cycles(self, parent_item, rel_type, direction, child_name):\r\n        \"\"\"\r\n        Handle cycles in the relationship data to avoid infinite loops.\r\n\r\n        Args:\r\n            parent_item (QStandardItem): The parent item in the tree.\r\n            rel_type (str): The type of the relationship.\r\n            direction (str): The direction of the relationship.\r\n            child_name (str): The name of the child node.\r\n        \"\"\"\r\n        rel_item = QStandardItem(f\"\uD83D\uDD04 [{rel_type}] ({direction})\")\r\n        rel_item.setIcon(QIcon(\"path/to/relationship_icon.png\"))\r\n\r\n        cycle_item = QStandardItem(f\"\uD83D\uDD01 {child_name} (Cycle)\")\r\n        cycle_item.setData(child_name, Qt.ItemDataRole.UserRole)\r\n        cycle_item.setIcon(QIcon(\"path/to/cycle_icon.png\"))\r\n\r\n        rel_item.appendRow(cycle_item)\r\n        parent_item.appendRow(rel_item)\r\n\r\n    @pyqtSlot(list)\r\n    def _populate_relationship_tree(self, records: List[Any]):\r\n        \"\"\"\r\n        Populate the tree view with relationships up to the specified depth.\r\n\r\n        Args:\r\n            records (List[Any]): The list of relationship records.\r\n        \"\"\"\r\n        logging.debug(f\"Populating relationship tree with records: {records}\")\r\n        try:\r\n            self.tree_model.clear()\r\n            self.tree_model.setHorizontalHeaderLabels([self.NODE_RELATIONSHIPS_HEADER])\r\n\r\n            if not records:\r\n                logging.info(\"No relationship records found.\")\r\n                return\r\n\r\n            root_node_name = self.ui.name_input.text().strip()\r\n            if not root_node_name:\r\n                logging.warning(\"Root node name is empty.\")\r\n                return\r\n\r\n            # Create root item with checkbox\r\n            root_item = QStandardItem(f\"\uD83D\uDD35 {root_node_name}\")\r\n            root_item.setData(root_node_name, Qt.ItemDataRole.UserRole)\r\n            root_item.setFlags(\r\n                Qt.ItemFlag.ItemIsEnabled\r\n                | Qt.ItemFlag.ItemIsSelectable\r\n                | Qt.ItemFlag.ItemIsUserCheckable\r\n            )\r\n            root_item.setCheckState(Qt.CheckState.Unchecked)\r\n            root_item.setIcon(QIcon(\"path/to/node_icon.png\"))\r\n\r\n            parent_child_map, skipped_records = self.process_relationship_records(\r\n                records\r\n            )\r\n\r\n            self.add_children(\r\n                root_node_name, root_item, [root_node_name], parent_child_map\r\n            )\r\n\r\n            self.tree_model.appendRow(root_item)\r\n            self.ui.tree_view.expandAll()\r\n            logging.info(\"Relationship tree populated successfully.\")\r\n\r\n            if skipped_records > 0:\r\n                logging.warning(\r\n                    f\"Skipped {skipped_records} incomplete relationship records.\"\r\n                )\r\n\r\n        except Exception as e:\r\n            self.handle_error(f\"Error populating relationship tree: {str(e)}\")\r\n\r\n    #############################################\r\n    # 7. Cleanup and Error Handling\r\n    #############################################\r\n\r\n    def cleanup(self):\r\n        \"\"\"\r\n        Clean up resources.\r\n        \"\"\"\r\n        # Cancel and wait for any running workers\r\n        for worker in [\r\n            self.current_load_worker,\r\n            self.current_save_worker,\r\n            self.current_relationship_worker,\r\n            self.current_search_worker,\r\n            self.current_delete_worker,\r\n        ]:\r\n            if worker is not None:\r\n                worker.cancel()\r\n                worker.wait()\r\n        self.model.close()\r\n\r\n    def handle_error(self, error_message: str):\r\n        \"\"\"\r\n        Handle any errors.\r\n\r\n        Args:\r\n            error_message (str): The error message to display.\r\n        \"\"\"\r\n        logging.error(error_message)\r\n        QMessageBox.critical(self.ui, \"Error\", error_message)\r\n\r\n    #############################################\r\n    # 8. Utility Methods\r\n    #############################################\r\n\r\n    def _parse_comma_separated(self, text: str) -> List[str]:\r\n        \"\"\"\r\n        Parse comma-separated input.\r\n\r\n        Args:\r\n            text (str): The comma-separated input text.\r\n\r\n        Returns:\r\n            List[str]: The parsed list of strings.\r\n        \"\"\"\r\n        return [item.strip() for item in text.split(\",\") if item.strip()]\r\n\r\n    def validate_node_name(self, name: str) -> bool:\r\n        \"\"\"\r\n        Validate node name.\r\n\r\n        Args:\r\n            name (str): The node name to validate.\r\n\r\n        Returns:\r\n            bool: True if the node name is valid, False otherwise.\r\n        \"\"\"\r\n        if not name:\r\n            QMessageBox.warning(self.ui, \"Warning\", \"Node name cannot be empty.\")\r\n            return False\r\n\r\n        if len(name) > self.config.LIMITS_MAX_NODE_NAME_LENGTH:\r\n            QMessageBox.warning(\r\n                self.ui,\r\n                \"Warning\",\r\n                f\"Node name cannot exceed {self.config.LIMITS_MAX_NODE_NAME_LENGTH} characters.\",\r\n            )\r\n            return False\r\n\r\n        return True\r\n\r\n    def change_image(self):\r\n        \"\"\"\r\n        Handle changing the image.\r\n        \"\"\"\r\n        try:\r\n            file_name, _ = QFileDialog.getOpenFileName(\r\n                self.ui,\r\n                \"Select Image\",\r\n                \"\",\r\n                \"Image Files (*.png *.jpg *.bmp)\",\r\n            )\r\n            if file_name:\r\n                # Process image in the UI thread since it's UI-related\r\n                self.current_image_path = file_name\r\n                self.ui.set_image(file_name)\r\n        except Exception as e:\r\n            self.handle_error(f\"Error changing image: {str(e)}\")\r\n\r\n    def delete_image(self):\r\n        \"\"\"\r\n        Handle deleting the image.\r\n        \"\"\"\r\n        self.current_image_path = None\r\n        self.ui.set_image(None)\r\n\r\n    def export_as_json(self):\r\n        \"\"\"\r\n        Export selected nodes data as JSON file.\r\n        \"\"\"\r\n        selected_nodes = self.get_selected_nodes()\r\n        if not selected_nodes:\r\n            QMessageBox.warning(self.ui, \"Warning\", \"No nodes selected for export.\")\r\n            return\r\n\r\n        file_name, _ = QFileDialog.getSaveFileName(\r\n            self.ui, \"Export as JSON\", \"\", \"JSON Files (*.json)\"\r\n        )\r\n        if file_name:\r\n            try:\r\n                all_node_data = []\r\n                for node_name in selected_nodes:\r\n                    if node_data := self._collect_node_data_for_export(node_name):\r\n                        all_node_data.append(node_data)\r\n\r\n                with open(file_name, \"w\") as file:\r\n                    json.dump(all_node_data, file, indent=4)\r\n                QMessageBox.information(\r\n                    self.ui,\r\n                    \"Success\",\r\n                    \"Selected nodes data exported as JSON successfully\",\r\n                )\r\n            except Exception as e:\r\n                self.handle_error(\r\n                    f\"Error exporting selected nodes data as JSON: {str(e)}\"\r\n                )\r\n\r\n    def export_as_txt(self):\r\n        \"\"\"\r\n        Export selected nodes data as plain text file.\r\n        \"\"\"\r\n        selected_nodes = self.get_selected_nodes()\r\n        if not selected_nodes:\r\n            QMessageBox.warning(self.ui, \"Warning\", \"No nodes selected for export.\")\r\n            return\r\n\r\n        file_name, _ = QFileDialog.getSaveFileName(\r\n            self.ui, \"Export as TXT\", \"\", \"Text Files (*.txt)\"\r\n        )\r\n        if file_name:\r\n            try:\r\n                with open(file_name, \"w\") as file:\r\n                    for node_name in selected_nodes:\r\n                        if node_data := self._collect_node_data_for_export(\r\n                            node_name\r\n                        ):\r\n                            file.write(f\"Name: {node_data['name']}\\n\")\r\n                            file.write(f\"Description: {node_data['description']}\\n\")\r\n                            file.write(f\"Tags: {', '.join(node_data['tags'])}\\n\")\r\n                            file.write(f\"Labels: {', '.join(node_data['labels'])}\\n\")\r\n                            file.write(\"Relationships:\\n\")\r\n                            for rel in node_data[\"relationships\"]:\r\n                                file.write(\r\n                                    f\"  - Type: {rel[0]}, Target: {rel[1]}, Direction: {rel[2]}, Properties: {json.dumps(rel[3])}\\n\"\r\n                                )\r\n                            file.write(\"Additional Properties:\\n\")\r\n                            for key, value in node_data[\r\n                                \"additional_properties\"\r\n                            ].items():\r\n                                file.write(f\"  - {key}: {value}\\n\")\r\n                            file.write(\"\\n\")\r\n                QMessageBox.information(\r\n                    self.ui,\r\n                    \"Success\",\r\n                    \"Selected nodes data exported as TXT successfully\",\r\n                )\r\n            except Exception as e:\r\n                self.handle_error(\r\n                    f\"Error exporting selected nodes data as TXT: {str(e)}\"\r\n                )\r\n\r\n    def export_as_csv(self):\r\n        \"\"\"\r\n        Export selected nodes data as CSV file.\r\n        \"\"\"\r\n        selected_nodes = self.get_selected_nodes()\r\n        if not selected_nodes:\r\n            QMessageBox.warning(self.ui, \"Warning\", \"No nodes selected for export.\")\r\n            return\r\n\r\n        file_name, _ = QFileDialog.getSaveFileName(\r\n            self.ui, \"Export as CSV\", \"\", \"CSV Files (*.csv)\"\r\n        )\r\n        if file_name:\r\n            try:\r\n                with open(file_name, \"w\") as file:\r\n                    file.write(\r\n                        \"Name,Description,Tags,Labels,Relationships,Additional Properties\\n\"\r\n                    )\r\n                    for node_name in selected_nodes:\r\n                        if node_data := self._collect_node_data_for_export(\r\n                            node_name\r\n                        ):\r\n                            file.write(\r\n                                f\"{node_data['name']},{node_data['description']},{', '.join(node_data['tags'])},{', '.join(node_data['labels'])},\"\r\n                            )\r\n                            relationships = \"; \".join(\r\n                                [\r\n                                    f\"Type: {rel[0]}, Target: {rel[1]}, Direction: {rel[2]}, Properties: {json.dumps(rel[3])}\"\r\n                                    for rel in node_data[\"relationships\"]\r\n                                ]\r\n                            )\r\n                            additional_properties = \"; \".join(\r\n                                [\r\n                                    f\"{key}: {value}\"\r\n                                    for key, value in node_data[\r\n                                        \"additional_properties\"\r\n                                    ].items()\r\n                                ]\r\n                            )\r\n                            file.write(f\"{relationships},{additional_properties}\\n\")\r\n                QMessageBox.information(\r\n                    self.ui,\r\n                    \"Success\",\r\n                    \"Selected nodes data exported as CSV successfully\",\r\n                )\r\n            except Exception as e:\r\n                self.handle_error(\r\n                    f\"Error exporting selected nodes data as CSV: {str(e)}\"\r\n                )\r\n\r\n    def export_as_pdf(self):\r\n        \"\"\"\r\n        Export selected nodes data as PDF file.\r\n        \"\"\"\r\n        from fpdf import FPDF\r\n\r\n        selected_nodes = self.get_selected_nodes()\r\n        if not selected_nodes:\r\n            QMessageBox.warning(self.ui, \"Warning\", \"No nodes selected for export.\")\r\n            return\r\n\r\n        file_name, _ = QFileDialog.getSaveFileName(\r\n            self.ui, \"Export as PDF\", \"\", \"PDF Files (*.pdf)\"\r\n        )\r\n        if file_name:\r\n            try:\r\n                pdf = FPDF()\r\n                pdf.set_font(\"Arial\", size=12)\r\n\r\n                for node_name in selected_nodes:\r\n                    if node_data := self._collect_node_data_for_export(node_name):\r\n                        pdf.add_page()\r\n                        pdf.cell(200, 10, txt=f\"Name: {node_data['name']}\", ln=True)\r\n                        pdf.cell(\r\n                            200,\r\n                            10,\r\n                            txt=f\"Description: {node_data['description']}\",\r\n                            ln=True,\r\n                        )\r\n                        pdf.cell(\r\n                            200,\r\n                            10,\r\n                            txt=f\"Tags: {', '.join(node_data['tags'])}\",\r\n                            ln=True,\r\n                        )\r\n                        pdf.cell(\r\n                            200,\r\n                            10,\r\n                            txt=f\"Labels: {', '.join(node_data['labels'])}\",\r\n                            ln=True,\r\n                        )\r\n                        pdf.cell(200, 10, txt=\"Relationships:\", ln=True)\r\n                        for rel in node_data[\"relationships\"]:\r\n                            pdf.cell(\r\n                                200,\r\n                                10,\r\n                                txt=f\"  - Type: {rel[0]}, Target: {rel[1]}, Direction: {rel[2]}, Properties: {json.dumps(rel[3])}\",\r\n                                ln=True,\r\n                            )\r\n                        pdf.cell(200, 10, txt=\"Additional Properties:\", ln=True)\r\n                        for key, value in node_data[\"additional_properties\"].items():\r\n                            pdf.cell(200, 10, txt=f\"  - {key}: {value}\", ln=True)\r\n\r\n                pdf.output(file_name)\r\n                QMessageBox.information(\r\n                    self.ui,\r\n                    \"Success\",\r\n                    \"Selected nodes data exported as PDF successfully\",\r\n                )\r\n            except Exception as e:\r\n                self.handle_error(\r\n                    f\"Error exporting selected nodes data as PDF: {str(e)}\"\r\n                )\r\n\r\n    def get_selected_nodes(self) -> List[str]:\r\n        \"\"\"\r\n        Get the names of checked nodes in the tree view.\r\n        \"\"\"\r\n        selected_nodes = []\r\n        logging.debug(\"Starting to gather selected nodes.\")\r\n\r\n        def traverse_tree(parent_item):\r\n            \"\"\"Recursively traverse tree to find checked items\"\"\"\r\n            if parent_item.hasChildren():\r\n                for row in range(parent_item.rowCount()):\r\n                    child = parent_item.child(row)\r\n                    if child.hasChildren():\r\n                        # If this is a relationship item, check its children\r\n                        for child_row in range(child.rowCount()):\r\n                            node_item = child.child(child_row)\r\n                            if (\r\n                                node_item\r\n                                and node_item.checkState() == Qt.CheckState.Checked\r\n                                and node_item.data(Qt.ItemDataRole.UserRole)\r\n                            ):\r\n                                selected_nodes.append(\r\n                                    node_item.data(Qt.ItemDataRole.UserRole)\r\n                                )\r\n                        traverse_tree(child)\r\n                    else:\r\n                        # If this is a node item directly\r\n                        if child.checkState() == Qt.CheckState.Checked and child.data(\r\n                            Qt.ItemDataRole.UserRole\r\n                        ):\r\n                            selected_nodes.append(child.data(Qt.ItemDataRole.UserRole))\r\n\r\n        # Start traversal from root\r\n        root_item = self.tree_model.invisibleRootItem()\r\n        traverse_tree(root_item)\r\n\r\n        # Remove duplicates while preserving order\r\n        unique_nodes = list(dict.fromkeys(selected_nodes))\r\n        logging.debug(f\"Found checked nodes: {unique_nodes}\")\r\n        return unique_nodes\r\n\r\n    def _collect_node_data_for_export(self, node_name: str) -> Optional[Dict[str, Any]]:\r\n        \"\"\"\r\n        Collect node data for export.\r\n\r\n        Args:\r\n            node_name (str): The name of the node to collect data for.\r\n\r\n        Returns:\r\n            Optional[Dict[str, Any]]: The collected node data.\r\n        \"\"\"\r\n        try:\r\n            node_data = {\r\n                \"name\": node_name,\r\n                \"description\": self.ui.description_input.toPlainText().strip(),\r\n                \"tags\": self._parse_comma_separated(self.ui.tags_input.text()),\r\n                \"labels\": [\r\n                    label.strip().upper().replace(\" \", \"_\")\r\n                    for label in self._parse_comma_separated(\r\n                        self.ui.labels_input.text()\r\n                    )\r\n                ],\r\n                \"relationships\": self._collect_relationships(),\r\n                \"additional_properties\": self._collect_properties(),\r\n            }\r\n\r\n            if self.current_image_path:\r\n                node_data[\"additional_properties\"][\r\n                    \"image_path\"\r\n                ] = self.current_image_path\r\n            else:\r\n                node_data[\"additional_properties\"][\"image_path\"] = None\r\n\r\n            return node_data\r\n        except ValueError as e:\r\n            self.handle_error(str(e))\r\n            return None
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ui/controller.py b/src/ui/controller.py
--- a/src/ui/controller.py	(revision e7d16f6f56e7750d5faef1a52db54b0031677460)
+++ b/src/ui/controller.py	(date 1731176267185)
@@ -4,8 +4,14 @@
 
 from PyQt6.QtCore import QObject, QStringListModel, Qt, pyqtSlot, QTimer
 from PyQt6.QtGui import QStandardItemModel, QStandardItem, QIcon
-from PyQt6.QtWidgets import QAbstractItemView, QCompleter, QLineEdit, QMessageBox, QTableWidgetItem, \
-    QFileDialog
+from PyQt6.QtWidgets import (
+    QAbstractItemView,
+    QCompleter,
+    QLineEdit,
+    QMessageBox,
+    QTableWidgetItem,
+    QFileDialog,
+)
 
 from core.neo4jworkers import SuggestionWorker
 from ui.dialogs import SuggestionDialog
@@ -196,7 +202,7 @@
         # Table buttons
         self.ui.add_rel_button.clicked.connect(self.ui.add_relationship_row)
 
-        #connect the suggest button
+        # connect the suggest button
         self.ui.suggest_button.clicked.connect(self.show_suggestions_modal)
 
         # Check for unsaved changes
@@ -213,8 +219,6 @@
             self.update_unsaved_changes_indicator
         )
 
-
-
         # Depth spinbox change
         self.ui.depth_spinbox.valueChanged.connect(self.on_depth_changed)
 
@@ -393,11 +397,16 @@
             logging.debug("Existing SuggestionWorker canceled and cleaned up.")
 
         # Create and start the SuggestionWorker
-        self.current_suggestion_worker = SuggestionWorker(self.model._uri, self.model._auth,
-                                                          node_data)
-        self.current_suggestion_worker.suggestions_ready.connect(self.handle_suggestions)
+        self.current_suggestion_worker = SuggestionWorker(
+            self.model._uri, self.model._auth, node_data
+        )
+        self.current_suggestion_worker.suggestions_ready.connect(
+            self.handle_suggestions
+        )
         self.current_suggestion_worker.error_occurred.connect(self.handle_error)
-        self.current_suggestion_worker.finished.connect(self.on_suggestion_worker_finished)
+        self.current_suggestion_worker.finished.connect(
+            self.on_suggestion_worker_finished
+        )
         self.current_suggestion_worker.start()
 
         logging.debug("SuggestionWorker started successfully.")
@@ -424,8 +433,9 @@
 
         if not suggestions or all(not suggestions[key] for key in suggestions):
             logging.debug("No suggestions found.")
-            QMessageBox.information(self.ui, "No Suggestions",
-                                    "No suggestions were found for this node.")
+            QMessageBox.information(
+                self.ui, "No Suggestions", "No suggestions were found for this node."
+            )
             return
 
         dialog = SuggestionDialog(suggestions, self.ui)
@@ -435,24 +445,30 @@
 
             # Update tags
             existing_tags = self._parse_comma_separated(self.ui.tags_input.text())
-            new_tags = list(set(existing_tags + selected['tags']))
-            self.ui.tags_input.setText(', '.join(new_tags))
+            new_tags = list(set(existing_tags + selected["tags"]))
+            self.ui.tags_input.setText(", ".join(new_tags))
             logging.debug(f"Updated tags: {new_tags}")
 
             # Update properties
-            for key, value in selected['properties'].items():
+            for key, value in selected["properties"].items():
                 self.add_or_update_property(key, value)
                 logging.debug(f"Updated property - Key: {key}, Value: {value}")
 
             # Update relationships
-            for rel in selected['relationships']:
+            for rel in selected["relationships"]:
                 rel_type, target, direction, props = rel
-                self.ui.add_relationship_row(rel_type, target, direction, json.dumps(props))
+                self.ui.add_relationship_row(
+                    rel_type, target, direction, json.dumps(props)
+                )
                 logging.debug(
-                    f"Added relationship - Type: {rel_type}, Target: {target}, Direction: {direction}, Properties: {props}")
+                    f"Added relationship - Type: {rel_type}, Target: {target}, Direction: {direction}, Properties: {props}"
+                )
 
-            QMessageBox.information(self.ui, "Suggestions Applied",
-                                    "Selected suggestions have been applied to the node.")
+            QMessageBox.information(
+                self.ui,
+                "Suggestions Applied",
+                "Selected suggestions have been applied to the node.",
+            )
         else:
             logging.debug("Suggestion dialog was canceled by the user.")
 
@@ -1068,9 +1084,7 @@
             try:
                 with open(file_name, "w") as file:
                     for node_name in selected_nodes:
-                        if node_data := self._collect_node_data_for_export(
-                            node_name
-                        ):
+                        if node_data := self._collect_node_data_for_export(node_name):
                             file.write(f"Name: {node_data['name']}\n")
                             file.write(f"Description: {node_data['description']}\n")
                             file.write(f"Tags: {', '.join(node_data['tags'])}\n")
@@ -1115,9 +1129,7 @@
                         "Name,Description,Tags,Labels,Relationships,Additional Properties\n"
                     )
                     for node_name in selected_nodes:
-                        if node_data := self._collect_node_data_for_export(
-                            node_name
-                        ):
+                        if node_data := self._collect_node_data_for_export(node_name):
                             file.write(
                                 f"{node_data['name']},{node_data['description']},{', '.join(node_data['tags'])},{', '.join(node_data['labels'])},"
                             )
@@ -1286,4 +1298,4 @@
             return node_data
         except ValueError as e:
             self.handle_error(str(e))
-            return None
\ No newline at end of file
+            return None
